{% extends "base.html" %}
{% load static %}
{% block content %}
<div class="container my-3">
    <h2>매칭 결과</h2>
    <ul id="match-list">
        <!-- 여기서 매칭된 후보의 공개 프로필 정보를 목록으로 표시합니다. -->
    </ul>
    <div id="contact-info" class="mt-3">
        <!-- 여성이 후보를 선택하면 해당 후보의 연락처를 표시 -->
    </div>
    <div id="no-matches" class="text-muted"></div>
    <form id="csrf-form">{% csrf_token %}</form>
</div>
{% endblock %}

{% block script %}
<script type="module">
import {
    hmacSign,
    generateRsaKeyPair, exportRsaPublicKey, importRsaPublicKey,
    rsaEncrypt, rsaDecrypt,
    deriveAesKey, aesEncrypt, aesDecrypt, getAesKey
} from "{% static 'crypto_utils.js' %}";    
    (async () => {
        const anon_id = "{{ anon_id }}";
        const csrf = document.querySelector('#csrf-form [name=csrfmiddlewaretoken]').value;
        

        // 1) 로그인 시 세션에 저장된 AES 키 꺼내기 · 없으면 재로그인 유도
        

        const key = await getAesKey(anon_id);

        // 2) 서버에서 encrypted_choices 받아와 복호화
        const resEnc = await fetch("{% url 'matching:choices_api' %}");
        const { encrypted_choices } = await resEnc.json();
        if (!encrypted_choices) {
            document.getElementById('no-matches').textContent = "내가 선택한 기록이 없습니다.";
            return;
        }
        const plainChoices = JSON.parse(await aesDecrypt(encrypted_choices, key));

        // 1) 서버가 준 매칭 리스트
        const res = await fetch("{% url 'matching:results_api' %}");
        const { matches } = await res.json();
        if (!matches.length) {
            document.getElementById('no-matches').textContent = "매칭된 상대가 없습니다.";
            return;
        }

        // 3) 평문 각각으로 태그 생성 → 일치하는 서버 태그 찾아 표시
        const serverSecretb64 = "{{ server_secret_b64 }}";

        const list = document.getElementById('match-list');
        list.innerHTML = '';
        for (let choice of plainChoices) {
            // console.log(JSON.stringify(choice));
            const tag = await hmacSign(JSON.stringify(choice), serverSecretb64);
            // console.log(tag);
            // 서버가 돌려준 matches 중 태그가 일치하는 후보 찾기
            const cand = matches.find(m => m.profile_tag === tag);
            if (!cand) continue;

            const li = document.createElement('li');
            li.innerHTML = `
                ${choice.name} (또래: ${choice.age}, 마을: ${choice.org})
                <button class="btn btn-sm btn-outline-primary get-contact-btn"
                        data-candidate-id="${cand.candidate_id}" data-pubkey="${cand.public_key}">
                연락처 전달하기
                </button>
            `;
            list.appendChild(li);
        }
        // if (!list.childElementCount) {
        //     list.innerHTML = '<li class="text-muted"> 매칭된 상대가 없습니다.</li>';
        // }


        const res_in = await fetch("{% url 'matching:get_myinfo_api' %}");
        const mydata = await res_in.json();

        // console.log('my enc phone: ', mydata.encrypted_phone);

        if (!mydata.encrypted_phone || mydata.encrypted_phone.length < 20) {
            throw new Error("연락처 암호문 형식이 이상함");
        }

        // 내 연락처 복호화
        // console.log('내 AES 키:', key);
        // console.log('내 암호화된 privkey:', mydata.encrypted_privkey);
        let privB64;
        try {
            privB64 = await aesDecrypt(mydata.encrypted_privkey, key);
            // console.log('복호화된 privB64:', privB64);
        } catch (err) {
            console.error("❌ 개인키 복호화 실패:", err);
            return;
        }
        // const privKey = await aesDecrypt(mydata.encrypted_privkey, key);
        // console.log('내 priv 키:', privKey);
        const privBytes = Uint8Array.from(atob(privB64), c => c.charCodeAt(0));

        // importKey로 RSA‑OAEP privateKey 복원
        const privateKey = await crypto.subtle.importKey(
            'pkcs8',
            privBytes.buffer,
            { name: 'RSA-OAEP', hash: 'SHA-256' },
            false,
            ['decrypt']
        );

        // console.log('복원된 RSA privateKey:', privateKey);

        // 2. 연락처 버튼 클릭 시
        document.getElementById('match-list').addEventListener('click', async e => {
            if (!e.target.classList.contains('get-contact-btn')) return;
            const candidateId = e.target.dataset.candidateId;
            const pubkeyPem = e.target.dataset.pubkey;
            // API 호출
            try {
                // 내 연락처 받기


                console.log("encrypted_phone length:", mydata.encrypted_phone.length);
                console.log("decoded length:", atob(mydata.encrypted_phone).length);

                const phone = await aesDecrypt(mydata.encrypted_phone, key);

                // let phone;
                // try {
                //     phone = await rsaDecrypt(privateKey, mydata.encrypted_phone);
                // } catch(err) {
                //     console.log('복호화 실패')
                //     return
                // }
                console.log('복호화된 번호:', phone);

                // 내 연락처 상대 공개키로 암호화
                const rsaPubKey = await importRsaPublicKey(pubkeyPem);
                const grantEnc_phone = await rsaEncrypt(rsaPubKey, phone);
                console.log('my phone: ', grantEnc_phone);

                const res = await fetch("{% url 'matching:grant_contact_api' %}", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrf },
                body: JSON.stringify({ to_user: candidateId, reencrypted_phone: grantEnc_phone })
            });

            } catch (err) {
                console.error("연락처 요청/복호화 실패", err);
                alert("연락처를 가져오는 데 실패했습니다.");
            }
        });

        // 상대방 연락처 받아서 복호화
        // const res_contact = await fetch("{% url 'matching:get_granted_contact_api' %}");
        // try {
            // 1) POST 해서 저장 & 재암호화된 전화번호 받기
            const res_contact = await fetch("{% url 'matching:grant_contact_api' %}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document
                        .querySelector('#csrf-form [name=csrfmiddlewaretoken]')
                        .value
                },
                body: JSON.stringify({
                    to_user: candidateId,
                    reencrypted_phone: reencrypted_phone
                })
            });
            const j = await res_contact.json();
            if (res_contact.status !== 200 || j.status !== 'ok') {
                throw new Error(j.error || 'grant 실패');
            }

            const plainPhone = await rsaDecrypt(privateKey, res.reencrypted_phone);
            document.getElementById('contact-info').textContent = `📞 연락처: ${plainPhone}`;
        // }
        // } catch (err) {
        //     console.error(err);
        //     alert('연락처 가져오기/복호화 실패');
        // }

    })();
</script>
{% endblock %}